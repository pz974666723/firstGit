https://github.com/AnkerLeng/Cpp-0-1-Resource

面向对象三大特性：封装，继承，多态
万事万物皆为对象，对象上有其属性和行为

ex:
    对象——人：
        属性：身高，年龄...
        行为：走，跑...
    对象——车：
        属性：长，车灯...
        行为：放音乐，开空调...

具有相同性质的对象，可以抽象为类，人——人类，车——车类


封装：  myPackage
    将属性和行为作为一个整体，表现生活中的事物
    将属性和行为加以权限控制
    语法：
        class 类名{  访问权限： 属性 / 行为}；    //属性和行为统一称为成员
            属性：
                成员属性 成员变量
            行为：
                成员函数 成员方法
                见basis.cpp
            访问权限：
                公共权限public        类内可以访问 类外可以访问
                保护权限protected     类内可以访问 类外不可以访问（子类可访问父类的protected）
                私有权限private       类内可以访问 类外不可以访问（子类不可访问父类的private）
                成员属性私有化：
                    1.自己控制读写权限
                    2.对于写可以检测数据的可读性


对象的初始化和清理：  ObjectCharacteristics
    编译器自动调用析构和构造，如果我们不提供构造和析构函数，编译器会提供，但都是空函数
    构造函数（初始化）：
        主要作用于创建对象时为对象的成员属性赋值，编译器自动调用
        语法：
            类名（）{}
            1.无返回值，无void
            2.函数名和类名相同
            3.可以有参数，可以重载
            4.自动调用，只会调用一次
        分类：
            按参数：有参构造  无参构造
            按类型：普通构造  拷贝构造（注意写法）
        调用：
            括号法
            显示法
            隐式转换法
        见ClassifyAndUse.cpp
        调用规则：
            用户定义了有参构造函数，c++不提供默认构造函数，但会提供拷贝构造函数
            用户定义了拷贝构造函数，c++不提供其他构造函数
        
    析构函数（清理）：
        语法：
            ~ 类名（）{}
            1.无返回值，无void
            2.函数名和类名相同，前面加 ~
            3.不可以有参数，不可以重载
            4.自动调用，只会调用一次
        主要作用于对象销毁前系统自动调用，执行一些清理工作

    深拷贝与浅拷贝
        拷贝和赋值是不同的定义，调用拷贝构造函数才叫拷贝
        但也存在拷贝赋值的概念 如：class Test t3 = t1;
        基本数据类型：直接存储在栈区的数据
        引用数据类型：存储的对象是栈中的引用，真实数据在堆区
        浅拷贝：简单的赋值拷贝操作（针对基本数据），增加了一个指针指向已存在的内存地址
            //类似于地址传递？其实只要不用new 两种传递方式都是浅拷贝
        深拷贝：增加了一个指针并在堆区重新申请空间，进行拷贝操作，须在析构函数中释放（针对引用数据）
            //类似于值传递？错误 深拷贝需要在 “堆区” 申请空间
        浅拷贝只复制某个对象的指针，不复制对象本身，新旧对象共享同一内存
        深拷贝会创造一个一模一样的对象，新旧对象不共享内存，修改新对象不会改变旧对象
        总结：
            如果属性有在堆区开辟（new）一定要自己提供拷贝构造函数（函数中也new），防止浅拷贝带来的问题

    初始化列表：
        另一种初始化方法
        语法：构造函数()： 属性1（值1），属性2（值2）...{}

    静态成员：
        在成员变量和成员函数前加上关键字static
        静态成员变量：
            1.所有对象共享同一份数据
            2.在编译阶段分配内存
            3.类内声明(static int m_b;)，类外初始化(int Person::m_b = 0;)
        静态成员函数：
            1.所有对象共享同一个函数
            2.静态成员函数只能访问静态成员变量
    1.成员变量和成员函数分开储存         StoreSeparately.cpp
    2.只有非静态成员变量才属于类的对象上


指针： Point
    分开储存：
        成员变量和成员函数分开储存  StoreSeparately.cpp
        只有非静态成员变量才属于类的对象上
        空对象占用内存空间为：1 -> 4(有了非静态成员变量后)
    this指针：
        静态函数会被很多对象调用
        this指针指向被调用的成员函数所属的对象（谁调用它，this指向谁）
        this指针隐含在每一个非静态成员函数内
        this指针不需要定义，直接使用即可
        用途：
            1.当形参和成员变量同名时，可以this区分
            2.在类的非静态成员函数中返回对象本身，可使用return *this
    空指针：
        空指针可以调用成员函数，但要注意有没有用到this指针
        如果用到this指针，需要加以判断
    const修饰成员函数：   constClass.cpp
        称为常函数
        常函数内不能修改成员属性
        成员属性声明时加了mutable后，在常函数中可以修改
    const修饰对象：
        称为常对象
        常对象只能调用常函数


友元：  friends
    让某些私有属性，可以被类外的一些特殊函数或类进行访问
    关键字：
        friend
    实现：
        1.全局函数做友元  globalFun.cpp
        2.类做友元        class.cpp
        3.成员函数做友元   member.cpp
          第三种情况下，如果类中含有另一个类作为成员变量，注意他们的顺序不然就会出现错误
          WrongMember.cpp  即要先定义友元函数的那个类Goodgay，若友元函数类中有其他类成员属性Building，需在定义Goodgay前声明其他类Building


运算重载符：  OperationOverload
    对已有运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
    1.通过成员函数重载//Person p3 = p1.operator+(p2);
    2.通过全局函数重载//Person p3 = operator+(p1, p2);
    运算符重载 也可发生 函数重载
    内置运算符不可重载
        + : plus.cpp
        << :重载左移运算符配合友元可以实现输出自定义数据类型 ShiftLeft.cpp 
        ++ ：区分前置递增（返回引用）和后置递增（占位参数 返回值） Increase.cpp
        =: 重载运算符，使其具有深拷贝的功能 Assignment.cpp
        == !=: 关系运算符(还有> < ) Relationship.cpp
        (): 调用运算符（STL中常用） transfer.cpp


继承：  inherit
    下级成员除了拥有上一级的共性，还有自己的特性。好处：减少重复代码
    基本语法：
        class 子类 : 继承方式 父类
        子类=派生类  父类=基类
        子类包含两部分：
            1.父类继承的   （共性）
            2.自己增加的成员（个性）
        继承方式：  Inheritance.cpp
            父类的private属性子类无法访问
            1.公共继承public    ：public和protected属性在公共继承下属性不变
            2.保护继承protected ：public和protected属性在保护继承下变成了protected
            3.私有继承private   ：public和protected属性在私有继承变成了private
        对象模型：  ObjectModel.cpp
            父类所有非静态成员属性都会被子类继承下去，无论公私
            私有属性只是被编译器隐藏了，无法访问
        构造和析构顺序： order.cpp
            Father GZ 
            Son GZ
            Son XG
            Father XG
        子类和父类中成员同名：  SameName.cpp（同名就相当于重写函数）
            子类直接访问，父类需加上作用域后访问  s.Base::func();
            **原因：子类和父类出现同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数（父类中重载函数需加作用域访问）
            静态成员访问方式相同，不过通过类名访问时有两个作用域（Son::Base::m_a）  SameStatic.cpp
    多继承语法：
        class 子类：继承方式 父类1， 继承方式 父类2...
        两父类成员同名，在子类继承后，通过作用域解决
        一般不推荐使用多继承
    菱形继承：  Diamond.cpp
        概念：
            两个子类（羊类  驼类）继承同一个父类（动物类）
            又有某个类（羊驼类）同时继承了上述两个子类
        问题：
            1.羊和驼继承了动物的数据，羊驼使用时会产生二义性
            2.羊驼继承了两份动物的数据，实际只需要一份
            问题1通过作用域解决
            问题2利用虚继承解决，加上关键字virtual，Animal称为虚父类（虚基类）
                m_age的值为最后赋给他的值（28），且不需要用作用域区分
                实现方法见视频（vbptr虚基类指针——是一个指针偏移量）
                虚yang类地址0 虚tuo类地址4 yangtuo age地址为8
                yang中vbptr指向的vbtable中age地址偏移量为8  0+8=8
                tuo中vbptr指向的vbtable中age地址偏移量为4   4+4=8


多态：  Polymorphism
    静态多态：
        函数重载 和 运算符重载属于静态多态，复用函数名
    动态多态（大多数）：
        派生类（子类）和虚函数实现运行时多态
    区别：
        静态多态的函数地址早绑定 —— 编译阶段确定函数地址
        动态多态的函数地址晚绑定 —— 运行阶段确定函数地址
    动态多态  basis.cpp
        满足条件：
            1.有继承关系
            2.子类重写父类虚函数//重写！=重载：函数返回类型 函数名 参数列表 要完全相同（virtual可不加）
        注：//c++中允许子类父类间的转换（子类转化为父类是可以的——子类转换成父类的时候，也需要注意，只能是指针或者引用，不能是对象，除非有重写构造函数和赋值函数。）
        使用：
            父类指针或引用 指向子类对象 并调用虚函数 void doSpeak(Animal &animal){animal.speak();}  调用:doSpeak(Cat)
        原理：
            //写了虚函数后，该函数相当于多了一个（虚函数指针）vfptr
            //vfptr 指向 vftable
            //Cat继承animal后，也会有一个vfptr指向vftable  (vftable中记录了虚函数地址 &Animal::speak)
            //当子类重写父类的虚函数
            //子类的vftable内的虚函数地址会被子类重写的函数地址覆盖( &Animal::speak 被 &Cat::speak 代替)
            //当父类指针或引用指向子类对象{Animal &animal = cat;animal.speak()};(cat被取别名为animal，cat是一个Cat对象，因此会从Cat的vftable中找speak)时，发生多态
              （这里相当于父类的引用指针指向子类所存在的地址，然而子类中拥有父类的部分，所以这种转换合法，但该指针只能访问父类的成员变量和函数——本例中父类函数在子类被重写）
        优点： test1.cpp
            1.代码组织结构清晰
            2.可读性强
            3.利于前期和后期的扩展以及维护
            //在真实开发中 提倡 开闭原则
            //开闭原则：对扩展进行开放 对修改进行关闭
            *c++中提倡用多态设计程序架构
    纯虚函数和抽象类：  PureAndAbstract.cpp
        纯虚函数语法：
            virtual 返回值类型 函数名 （参数列表） = 0；
            有了纯虚函数，这个类就叫抽象类
        抽象类特点：
            抽象类可以创建指针，无法创建对象
            1.无法实例化对象
            2.子类必须重写抽象类的纯虚函数，否则无法实例化对象
    虚析构和纯虚析构：  视频中是VirtualXG.cpp  (比较myXGtest.cpp/myXGtest2.cpp/VirtualXG.cpp在调试和直接运行时的区别)    vscode终端在这3个文件中是有问题的，调试正常
                       //父类指针指向子类对象，最后释放了父类的（delete animal;）
        多态使用时，(父类指针或引用指向子类对象)如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码
        即利用虚析构可解决这一问题可以解决父类指针释放子类对象不干净的问题
        解决方式：
            将父类中的析构函数改为虚析构或者纯虚析构
        共性：
            1.可以解决父类指针释放子类对象
            2.都需要有具体的函数实现
        区别：
            如果是纯虚析构，该类属于抽象类，无法实例化对象
        虚析构语法：
            virtual ~类名(){}
        纯虚析构语法：（类内声明，类外实现）
            virtual ~类名() = 0;
            类名::~类名(){}
        总结：
            1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象
            2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
            3. 拥有纯虚析构函数的类也属于抽象类


文件操作：  FileOperations
    通过文件可以将数据持久化
    C++中对文件操作需要包含头文件 ==< fstream >==
    文件操作：
        1.ofstream： 写操作(output file)  ofs是往文件上输出=写文件 cout是往屏幕上输出=显示
        2.ifstream： 读操作(input file)
        3.fstream ： 读写操作(file)
    文件类型：
        1.文本文件：
            - 文件以文本的ASCII码形式存储在计算机中
            写文件步骤如下： WriteTXT.cpp
                1.包含头文件                    #include <fstream>
                2.创建流对象                    ofstream ofs;
                3.打开文件                      ofs.open("文件路径",打开方式);
                4.写数据                        ofs << "写入的数据";
                5.关闭文件                      ofs.close();
            读文件步骤如下： ReadTXT.cpp
                1.包含头文件                    #include <fstream>
                2.创建流对象                    ifstream ifs;
                3.打开文件并判断文件是否打开成功  ifs.open("文件路径",打开方式);  if ( !ifs.is_open()){return;}
                4.读数据                        四种方式读取
                5.关闭文件                      ifs.close();
        2.二进制文件：
            - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们
            写文件：  WriteBinary.cpp
                二进制方式写文件主要利用流对象调用成员函数write
                函数原型 ：ostream& write(const char * buffer,int len);
                参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数
            读文件：  ReadBinary.cpp
                二进制方式写文件主要利用流对象调用成员函数read
                函数原型 ：istream& read(char *buffer,int len);
                参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数
    打开方式：	
        ios::in 	为读文件而打开文件
        ios::out	为写文件而打开文件
        ios::ate	初始位置：文件尾
        ios::app	追加方式写文件
        ios::trunc	如果文件存在先删除，再创建
        ios::binary	二进制方式
        注意：文件打开方式可以配合使用，利用|操作符
        例如：用二进制方式写文件  ios::binary | ios:: out
    
    


            
    